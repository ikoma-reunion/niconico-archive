<?xml version="1.0" encoding="UTF-8"?>
<nicovideo_thumb_response status="ok"><thumb><video_id>sm44769574</video_id><title>[Blender]Geometry Nodeの UVマッピングの基本メモ4[デモ]</title><description>[Blender]Geometry Nodeの UVマッピングの基本メモ4[デモ]その４UVUnwrapシームを入れるずんだもんが勉強するシリーズその１その２その３補足:訂正：UV展開できないというのは自分がやり方が間違っていただけ、でIndexを使っても別のやり方でできるので紛らわしい部分は取り消しました。私の質問の仕方が悪かったのですがAIの回答はIndexノードが正確でないという意味ではなく、場合によっては Edge Verticesを利用するほうが良い、程度意味でしょう。今回はEdgeのIndexを取得するのにGeometry＞Read＞Indexノードを使ったが、カーブの種類によってはうまくEdgeのIndexを取得できない（UV UnwrapにSeamとして渡してもうまくUV展開できない）ことがあった。そういうケースではMesh＞Read&amp;gt;Edge Verticesノードを使ったら上手くできた。ずんだもんからの質問:Edge Verticesノードが正確にEdgeのインデックスを取得できるということでよろしいですか？ChatGPT: はい、その認識で合っています。 Edge Vertices ノード を使うと、各エッジの両端の頂点インデックス (Index A と Index B) を正確に取得できます。 これにより、特定のエッジを正しく識別 し、シームを設定できます。なぜ Edge Vertices を使うのか？ Curve to Mesh の後のエッジインデックスは、Profile Curve の繰り返し構造の影響を受ける Index だけでは、どのエッジが円周方向のものなのかを正確に判断できない Edge Vertices を使えば、各エッジの両端の頂点を直接チェックできる Index A を 8 で割った余りが 0 の場合、そのエッジはシームにすべきエッジであると特定可能 つまり、エッジの位置を知るために「エッジ自体のインデックス」ではなく「エッジを構成する頂点のインデックス」を使う のがポイントです。この回答の補足：前提として、「CurveToMeshノードで、Resolutionが 8 の＋Zに延びる円柱を作って、シームを入れる縦の一列のエッジのIndexを取得（IndexのModulo 8 が 0 であるエッジ）して、UVUnwrapノードに渡したがうまくUV展開できなかった」ケースについて質問していた。</description><thumbnail_url>https://nicovideo.cdn.nimg.jp/thumbnails/44769574/44769574.23118856</thumbnail_url><first_retrieve>2025-03-16T19:16:03+09:00</first_retrieve><length>11:23</length><movie_type>mp4</movie_type><size_high>1</size_high><size_low>1</size_low><view_counter>34</view_counter><comment_num>0</comment_num><mylist_counter>0</mylist_counter><last_res_body/><watch_url>https://www.nicovideo.jp/watch/sm44769574</watch_url><thumb_type>video</thumb_type><embeddable>1</embeddable><no_live_play>0</no_live_play><tags domain="jp"/><genre>未設定</genre><user_id>15146164</user_id><user_nickname>Kaz PGDC</user_nickname><user_icon_url>https://secure-dcdn.cdn.nimg.jp/nicoaccount/usericon/1514/15146164.jpg?1596079895</user_icon_url></thumb></nicovideo_thumb_response>
